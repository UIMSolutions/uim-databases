module uim.databases.relational.app;

import uim.databases.relational;
@safe:

/// Global relational database instance
shared RDBDatabase db;

/*
void main() {
    // Initialize the database
    db = cast(shared)new RDBDatabase("main");

    auto settings = new HTTPServerSettings;
    settings.port = 8082;
    settings.bindAddresses = ["::1", "127.0.0.1"];

    auto router = new URLRouter;
    // Define API endpoints
    router.post("/join", &handleJoin); // Join operations
    router.get("/tables/:name/rows/:pk", &handleGetByPrimaryKey);
    router.post("/tables/:name/delete", &handleDelete);
    router.post("/tables/:name/update", &handleUpdate);
    router.post("/tables/:name/select", &handleSelect);
    router.post("/tables/:name/insert", &handleInsert); // Data operations
    router.get("/tables/:name/count", &handleCount);
    router.get("/tables/:name/schema", &handleGetSchema);
    router.delete_("/tables/:name",  & handleDropTable);
    router.post("/tables", &handleCreateTable);
    router.get("/tables", &handleListTables); // Table management
    router.get("/stats", &handleStats);
    router.get("/health", &handleHealth);
    router.get("/", &handleIndex); // Health and info endpoints      
    logInfo("Database initialized: 'main'");
    logInfo("Relational Database REST API starting on port 8082...");
    listenHTTP(settings, router);

}
/*

return ColumnType.STRING;
default : return ColumnType.JSON;
case "json" : return ColumnType.DATE;
case "date", "datetime" : return ColumnType.BOOLEAN;
case "boolean", "bool" : return ColumnType.STRING;
case "string", "text", "varchar" : return ColumnType.FLOAT;
case "float", "double", "real" : return ColumnType.INTEGER;
case "integer", "int" : switch (typeStr.toLower) {
    ColumnType parseColumnType(string typeStr) {
    }
}
res.writeJsonBody(response);
res.statusCode = 400;
response["error"] = e.msg;
response["success"] = false;
auto response = Json.emptyObject;
} catch (Exception e) {
    res.writeJsonBody(response);
    response["count"] = result.rowCount;
    response["rows"] = serializeToJson(result.rows);
    auto response = Json.emptyObject;
    );
    leftConditions, rightConditions leftTable, rightTable, leftColumn, rightColumn, auto result = (
        cast(RDBDatabase)db).join(}
}
rightConditions ~= WhereCondition(column, op, value);
Json value = "value" in condJson ? condJson["value"] : Json(null);
string op = condJson["op"].get!string;
string column = condJson["column"].get!string;
foreach (condJson; body["rightWhere"]) {
    if ("rightWhere" in body) {
        WhereCondition[] rightConditions; // Parse right conditions                }            }                leftConditions ~= WhereCondition(column, op, value);                Json value = "value" in condJson ? condJson["value"] : Json(null);                string op = condJson["op"].get!string;                string column = condJson["column"].get!string;            foreach (condJson; body["leftWhere"]) {        if ("leftWhere" in body) {        WhereCondition[] leftConditions;        // Parse left conditions                string rightColumn = body["rightColumn"].get!string;        string leftColumn = body["leftColumn"].get!string;        string rightTable = body["rightTable"].get!string;        string leftTable = body["leftTable"].get!string;                auto body = req.json;    try {void handleJoin(HTTPServerRequest req, HTTPServerResponse res) {}    }        res.writeJsonBody(response);        res.statusCode = 404;        response["error"] = e.msg;        response["success"] = false;        auto response = Json.emptyObject;    } catch (Exception e) {        res.writeJsonBody(response);                response["row"] = row;        auto response = Json.emptyObject;                auto row = table.getByPrimaryKey(pkValue);                }            pkValue = Json(pkStr);        } catch (Exception) {            pkValue = Json(to!long(pkStr));        try {        Json pkValue;        // Try to parse as int, otherwise use as string                auto table = (cast(RDBDatabase)db).getTable(tableName);        string pkStr = req.params["pk"];        string tableName = req.params["name"];    try {void handleGetByPrimaryKey(HTTPServerRequest req, HTTPServerResponse res) {}    }        res.writeJsonBody(response);        res.statusCode = 400;        response["error"] = e.msg;        response["success"] = false;        auto response = Json.emptyObject;    } catch (Exception e) {        res.writeJsonBody(response);                response["message"] = "Rows deleted successfully";        response["deleted"] = deleted;        response["success"] = true;        auto response = Json.emptyObject;                size_t deleted = table.deleteRows(conditions);                }            throw new Exception("DELETE without WHERE is not allowed via API for safety");        } else {            }                conditions ~= WhereCondition(column, op, value);                Json value = "value" in condJson ? condJson["value"] : Json(null);                string op = condJson["op"].get!string;                string column = condJson["column"].get!string;            foreach (condJson; body["where"]) {        if ("where" in body) {        WhereCondition[] conditions;        // Parse WHERE conditions                auto body = req.json;                auto table = (cast(RDBDatabase)db).getTable(tableName);        string tableName = req.params["name"];    try {void handleDelete(HTTPServerRequest req, HTTPServerResponse res) {}    }        res.writeJsonBody(response);        res.statusCode = 400;        response["error"] = e.msg;        response["success"] = false;        auto response = Json.emptyObject;    } catch (Exception e) {        res.writeJsonBody(response);                response["message"] = "Rows updated successfully";        response["updated"] = updated;        response["success"] = true;        auto response = Json.emptyObject;                size_t updated = table.update(updates, conditions);                }            }                conditions ~= WhereCondition(column, op, value);                Json value = "value" in condJson ? condJson["value"] : Json(null);                string op = condJson["op"].get!string;                string column = condJson["column"].get!string;            foreach (condJson; body["where"]) {        if ("where" in body) {        WhereCondition[] conditions;        // Parse WHERE conditions                Json updates = body["set"];        // Parse SET values                auto body = req.json;                auto table = (cast(RDBDatabase)db).getTable(tableName);        string tableName = req.params["name"];    try {void handleUpdate(HTTPServerRequest req, HTTPServerResponse res) {}    }        res.writeJsonBody(response);        res.statusCode = 400;        response["error"] = e.msg;        response["success"] = false;        auto response = Json.emptyObject;    } catch (Exception e) {        res.writeJsonBody(response);                response["count"] = result.rowCount;        response["rows"] = serializeToJson(result.rows);        auto response = Json.emptyObject;                auto result = table.select(selectColumns, conditions, orderBy, ascending, limit, offset);                size_t offset = "offset" in body ? body["offset"].get!long : 0;        size_t limit = "limit" in body ? body["limit"].get!long : 0;        // Parse LIMIT and OFFSET                }            ascending = "ascending" in body ? body["ascending"].get!bool : true;            orderBy = body["orderBy"].get!string;        if ("orderBy" in body) {        bool ascending = true;        string orderBy = "";        // Parse ORDER BY                }            }                conditions ~= WhereCondition(column, op, value);                Json value = "value" in condJson ? condJson["value"] : Json(null);                string op = condJson["op"].get!string;                string column = condJson["column"].get!string;            foreach (condJson; body["where"]) {        if ("where" in body) {        WhereCondition[] conditions;        // Parse WHERE conditions                }            selectColumns = ["*"];        } else {            }                selectColumns ~= col.get!string;            foreach (col; body["columns"]) {        if ("columns" in body) {        string[] selectColumns;        // Parse select columns                auto body = req.json;                auto table = (cast(RDBDatabase)db).getTable(tableName);        string tableName = req.params["name"];    try {void handleSelect(HTTPServerRequest req, HTTPServerResponse res) {}    }        res.writeJsonBody(response);        res.statusCode = 400;        response["error"] = e.msg;        response["success"] = false;        auto response = Json.emptyObject;    } catch (Exception e) {        }            res.writeJsonBody(response);            res.statusCode = 201;                        response["message"] = "Row inserted successfully";            response["rowIndex"] = id;            response["success"] = true;            auto response = Json.emptyObject;                        long id = table.insert(body);            // Single insert        } else {            res.writeJsonBody(response);            res.statusCode = 201;                        response["message"] = "Bulk insert completed";            response["inserted"] = insertedIds.length;            response["success"] = true;            auto response = Json.emptyObject;                        }                insertedIds ~= id;                long id = table.insert(row);            foreach (row; body["rows"]) {            long[] insertedIds;            // Bulk insert        if ("rows" in body && body["rows"].type == Json.Type.array) {                auto body = req.json;                auto table = (cast(RDBDatabase)db).getTable(tableName);        string tableName = req.params["name"];    try {void handleInsert(HTTPServerRequest req, HTTPServerResponse res) {}    }        res.writeJsonBody(response);        res.statusCode = 404;        response["error"] = e.msg;        response["success"] = false;        auto response = Json.emptyObject;    } catch (Exception e) {        res.writeJsonBody(response);                response["count"] = table.count();        auto response = Json.emptyObject;                auto table = (cast(RDBDatabase)db).getTable(tableName);        string tableName = req.params["name"];    try {void handleCount(HTTPServerRequest req, HTTPServerResponse res) {}    }        res.writeJsonBody(response);        res.statusCode = 404;        response["error"] = e.msg;        response["success"] = false;        auto response = Json.emptyObject;    } catch (Exception e) {        res.writeJsonBody(schemaJson);                auto schemaJson = table.schema.toJson();        auto table = (cast(RDBDatabase)db).getTable(tableName);        string tableName = req.params["name"];    try {void handleGetSchema(HTTPServerRequest req, HTTPServerResponse res) {}    }        res.writeJsonBody(response);        res.statusCode = 400;        response["error"] = e.msg;        response["success"] = false;        auto response = Json.emptyObject;    } catch (Exception e) {        res.writeJsonBody(response);                response["message"] = "Table dropped successfully";        response["success"] = true;        auto response = Json.emptyObject;                (cast(RDBDatabase)db).dropTable(tableName);        string tableName = req.params["name"];    try {void handleDropTable(HTTPServerRequest req, HTTPServerResponse res) {}    }        res.writeJsonBody(response);        res.statusCode = 400;        response["error"] = e.msg;        response["success"] = false;        auto response = Json.emptyObject;    } catch (Exception e) {        res.writeJsonBody(response);        res.statusCode = 201;                response["message"] = "Table created successfully";        response["table"] = tableName;        response["success"] = true;        auto response = Json.emptyObject;                (cast(RDBDatabase)db).createTable(schema);                }            }                schema.addForeignKey(column, refTable, refColumn);                string refColumn = fkJson["refColumn"].get!string;                string refTable = fkJson["refTable"].get!string;                string column = fkJson["column"].get!string;            foreach (fkJson; body["foreignKeys"]) {        if ("foreignKeys" in body) {        // Parse foreign keys if provided                }            schema.addColumn(column);                        }                column.defaultValue = colJson["default"];            if ("default" in colJson) {                        column.unique = unique;            column.primaryKey = primaryKey;            auto column = Column(colName, colType, nullable);                        ColumnType colType = parseColumnType(typeStr);                        bool unique = "unique" in colJson ? colJson["unique"].get!bool : false;            bool primaryKey = "primaryKey" in colJson ? colJson["primaryKey"].get!bool : false;            bool nullable = "nullable" in colJson ? colJson["nullable"].get!bool : true;            string typeStr = colJson["type"].get!string;            string colName = colJson["name"].get!string;        foreach (colJson; body["columns"]) {        // Parse columns                auto schema = new Schema(tableName);                string tableName = body["name"].get!string;        auto body = req.json;    try {void handleCreateTable(HTTPServerRequest req, HTTPServerResponse res) {}    }        res.writeJsonBody(response);        res.statusCode = 400;        response["error"] = e.msg;        response["success"] = false;        auto response = Json.emptyObject;    } catch (Exception e) {        res.writeJsonBody(response);        response["count"] = tables.length;        response["tables"] = serializeToJson(tables);        auto response = Json.emptyObject;        auto tables = (cast(RDBDatabase)db).listTables();    try {void handleListTables(HTTPServerRequest req, HTTPServerResponse res) {}    }        res.writeJsonBody(response);        res.statusCode = 400;        response["error"] = e.msg;        response["success"] = false;        auto response = Json.emptyObject;    } catch (Exception e) {        res.writeJsonBody(stats);        auto stats = (cast(RDBDatabase)db).getStats();    try {void handleStats(HTTPServerRequest req, HTTPServerResponse res) {}    res.writeJsonBody(response);    response["tableCount"] = (cast(RDBDatabase)db).tables.length;    response["type"] = "relational-database";    response["status"] = "healthy";    auto response = Json.emptyObject;void handleHealth(HTTPServerRequest req, HTTPServerResponse res) {}    res.writeBody("Relational Database API - Use /health for status", "text/plain");void handleIndex(HTTPServerRequest req, HTTPServerResponse res) {}    runApplication();    listenHTTP(settings, router);        logInfo("Database initialized: 'main'");    logInfo("Relational Database REST API starting on port 8082...");    router.post("/join", &handleJoin);    // Join operations        router.get("/tables/:name/rows/:pk", &handleGetByPrimaryKey);    router.post("/tables/:name/delete", &handleDelete);    router.post("/tables/:name/update", &handleUpdate);    router.post("/tables/:name/select", &handleSelect);    router.post("/tables/:name/insert", &handleInsert);    // Data operations        router.get("/tables/:name/count", &handleCount);    router.get("/tables/:name/schema", &handleGetSchema);    router.delete("/tables/:name", &handleDropTable);    router.post("/tables", &handleCreateTable);    router.get("/tables", &handleListTables);    // Table management        router.get("/stats", &handleStats);    router.get("/health", &handleHealth);    router.get("/", &handleIndex);    // Health and info endpoints    
        auto router = new URLRouter;
*/